## [230424 ←](/230130-_Spring/230424)

# 최후의 질문

## 1. 안보임

## 2. 자료 추상화(Data Abstraction)

- 1단원 63p E-R 다이어그램
    - 현실 세계에 존재하는 개체(Entity)들의 특징을 유형화, 집단화, 일반화하여 추상적 개념으로 표현하는 과정
        - Classification(유형화): 동일한 특성을 Class로 분류하여 정의
        - Aggregation(집단화): Aggregate하여 연관된 속성을 하나의 집단으로 분류
        - Generalization(일반화): 공통 속성을 파악하여 전체집합과 부분집합으로 분류 
- 4단원 12p 객체지향의 특징
    1. 캡슐화: 연관된 데이터와 데이터를 처리하는 함수를 함께 묶어 외부에는 필요한 인터페이스만을 노출한다.
    1. 정보 은닉: 다른 객체에게 자신의 필드 및 메소드 등을 은닉하고 자신의 연산만을 통하여 접근을 허용한다.
    1. **추상화**: 불필요한 부분은 생략하고 주어진 문제나 시스템 중에서 중요한 부분에 집중하여 모델링한다
    1. 상속: 하위 클래스에서 상위 클래스의 속성과 메소드를 물려받는 기법으로 클래스와 객체의 재사용이 가능하다.
    1. 다형성: 하나의 메시지에 대해 각 객체의 고유한 방법으로 응답한다.

## 3. CMD 창에서 help를 치면 나오는 명령어 설명?

- 2단원 12p 그림 1-3
- `BREAK`: 확장된 CTRL+C 검사를 설정하거나 지웁니다.
    - 참고로 안 쓰는 명령어라고 윈도우 도움말 페이지엔 기술되어 있다. MS-DOS 프로그램들과의 호환을 위해 남겨둔 거라고.
- `CHCP`: 활성화된 코드 페이지의 번호를 표시하거나 설정합니다.
    - CMD의 인코딩을 변경한다. 437이 미국, 949가 한국, 65001이 UTF-8이다.
- `CHKNTFS`: CheCK NTFS. 부팅하는 동안 디스크 확인을 화면에 표시하거나 변경합니다.
    - CHKDSK의 하위호환 느낌. 자세히는 몰?루

## 4. 서브쿼리 유형

- 6단원 15p 표 1-13

| 서브쿼리 종류 | 설명 |
|---|---|
| Single Row(단일 행) 서브쿼리 | <ul><li>서브쿼리의 결과가 항상 1건 이하인 서브쿼라</li><li>단일 행의 비교 연산자에는 `=`, `<`, `<=`, `>`, `>=`, `<>` 등이 사용</li></ul> |
| Multiple Row(다중 행) 서브쿼리 | <ul><li>서브쿼리 실행 결과가 여러 건인 서브쿼리</li><li>다중 행의 비교 연산자에는 `IN`, `EXISTS`, `ALL`, `ANY` 등이 사용</li></ul> |
| Multiple Column(다중 컬럼) 서브쿼리 | <ul><li>서브쿼리의 실행 결과가 두 개 이상의 컬럼으로 반환되는 쿼리</li><li>메인쿼리의 조건절에 다수의 컬럼을 비교할 때, 서브쿼리와 메인쿼리에서 비교하는 컬럼 개수, 위치가 동일해야 함</li></ul> |

## 5. if, while, switch

- 단원 찾을 것도 없이 기본 상식
- `if`: 조건이 참인지 거짓인지에 따라 경로를 선택
- `while`: 조건식이 거짓이 될 때까지 해당 문장을 반복해서 실행
- `switch`: 조건식에 따라 여러 개의 `case` 경로 중 하나를 취하고자 할 때 사용

## 6. 브리지 vs 스위치(안나옴)

- 하지만 스위치는 Cut-Through(패킷을 그대로 주소만 보고 넘김) 방식과 Store-and-Forward(패킷을 다 받은 다음 넘김, 에러 체크 가능) 방식을 둘 다 쓸 수 있지만, 브리지는 Store-and-Forward 방식밖에 사용하지 못한다.

## 7. 리눅스 명령어(안나옴)

- 하지만 2단원 13페이지에 있긴 있다.
- 정답인 `dmesg`는 부팅할 적에 커널에 남겨진 로그를 출력하는 명령어. 드라이버가 무엇이 로딩되었는지 확인할 수 있기 때문에 하드웨어 인식 여부 확인에 필수적이다. 하드웨어명을 넣어서 `grep`과 함께 사용한다.

## 8. 부하 테스트 기본 공식

- 9단원 37페이지

| 분류 | 기본 공식 내용 |
|---|---|
| 동시 이용자 수 | TPS * 호출간격(응답 시간(초) + 대기 시간(초)) |
| 동시 단말 이용자 | Active User + In-active User |
| Active User | - |
| 처리량(Throughput) | 의 단위가 TPS |
| 대기 시간 | 응답을 받은 직후부터 다음 명령 또는 호출할 때까지 사용자가 대기하는 시간 |

## 9. 결함 상태

- 9단원 27페이지

| 결함 상태 | 설명 |
|---|---|
| Open | 결함이 보고되었지만 아직 분석되지 않음 | 
| Assigned | 영향 분석 및 수정을 위해 결함을 개발자에게 할당한 상태 |
| Fixed | 개발자가 결함을 수정한 상태 |
| **Closed** | 결함이 수정되었는지 확인하고 회귀 테스트(수정 후에도 제대로 작동하는지 테스트) 시 결함이 발견되지 않은 상태. 수정된 결과가 만족스럽지 않을 경우, 결함의 상태를 'open'으로 변경한다. |
| Deferred | Prefer의 반대. 결함 우선(Preference) 순위가 낮게 분류되었기 때문에 결함 수정을 연기한 상태 |
| Clarified | 보고된 결함이 프로젝트 팀에 의해 결함이 아니라고 명확히 판단(Clarify)한 상태 |

## 10. 오픈소스 형상 관리 도구

- 9단원 66페이지
    - 정확하게 이 텍스트가 나오진 않음
- CVS는 초창기 형상 관리 도구로 서버가 단순한 명령 구조를 가졌다는 장점이 있지만 텍스트 기반의 코드만 지원한다는 약점이 있음
    - Apparently, 초창기라서 제약 사항이 많고 이 중에 프로젝트 전체를 관리할 수 없다는 단점이 있는 모양
- SVN(=Apache Subversion)은 다양한 GUI 도구가 존재하고 gzip 압축을 통해 서버의 공간을 절약하는 장점을 가지고 있지만, trunk, branch, tag가 모두 저장 위치를 점유한다는 단점이 있음
- Git은 앞서 나온 CVS와 SVN의 단점을 모두 보완했으나 중앙집중형인 앞의 둘과는 달리 분산형이기 때문에 개발자에게 학습할 시간을 필요로 함

## 11. 단위 테스트를 할 적의 Mock 객체

- 9단원 35페이지

| 객체 유형 | 수행 내용 |
|---|---|
| Dummy | 객체 전달에만 사용되고 실제로는 사용되지 않아 패러미터 목록만 채우는 데 쓰임 |
| Fake | 실제로 동작하도록 구현, 하지만 실제 환경과는 다름 |
| Stubs | **미리 준비한 응답만을 제공**, 이외에는 정상적 작동 X |
| Mocks | Stubs와 유사하나 준비된 응답 외에는 **예외**가 발생함 |

## 12. 자바스크립트가 할 수 없는 것

- 어딨는지 몰?루 걍 인터넷 검색함
- CSS의 변경이나 추가, 삭제는 당연히 할 수 있다.
    - `Element.style` 객체 아래쪽의 요소들을 수정함으로써 가능.
- 요소 변경이나 추가, 삭제도 가능(`document.createElement()`)
- 속성 변경이나 추가, 삭제도 가능(`Element.setAttribute()`)
- HTML 이벤트도 추가 가능(`Element.addEventListener()`)

## 13. 뷰의 장점과 단점

- 6단원 48페이지
- 장점
    - 논리적 독립성 제공
    - 데이터 보안 용이
    - 사용자 데이터 관리 용이
- 단점
    - 뷰의 인덱스 사용 불가
    - 뷰 구조, 정의 변경 불가
        - 삭제 후 재생성(`CREATE OR REPLACE`)을 통해서만 구조 변경이 가능
    - 데이터 변경 제약 존재

## 21. 사용성 테스트 진행 인원

- 8단원 18페이지
1. 테스트 진행자: 평과 진행 및 결과에 대해서 책임을 짐
1. 기록 담당자: 테스트 과정에서 발생할 수 있는 중요한 행위와 이벤트를 코드화시켜서 기록(문자적으로 기록)
1. 비디오 녹화 담당자: 테스트 과정에서 발생하는 모든 행위를 녹화하는 사람
1. 테스트 관찰자: 기타 사람들, 테스트 대상 제품 개발에 직간접적으로 관련이 있는 사람들

## 22. 테스트 커버리지

- 10단원 35페이지
    - 이지만 정확하게 그 텍스트는 없음
1. Statement Coverage; 라인 커버리지 또는 구문 커버리지
    - 각 소스의 각 라인이 수행되었는지를 확인하는 측정 지표이다.
1. Decision Coverage; 분기 커버리지
    - 개발 소스의 각 분기문이 수행되었는지를 확인하는 측정 지표이다. 만약 소스 내에 if문에 대한 true/false 조건이 있다면, 두 가지 경우가 모두 테스트되어야 100%로 측정된다.
1. Condition Coverage; 조건 커버리지
    - 각 분기문 내에 존재하는 **조건식**이 모두 테스트되었는지를 확인하는 측정 지표이다. 조건식 간의 조합에 대해서는 체크하지 않는다.

## 23. 테스트 계획서 항목

- 8단원 22페이지
- 뭔가 많은데 가상화 매체 여부는 없음

## 29. 데이터베이스 툴 선정

- 안보임

## 31. 프레임 릴레이

- 안보임

## 34. 형상 관리 기능

- 9단원 56페이지
- SCI: Software Configuration Item, 소프트웨어 형상 항목
    - 단순히 코드뿐만 아니라 명세서, 매뉴얼 등의 문서들도 포괄적으로 포함

| 단계 | 설명 |
|---|---|
| 형상 식별 | 형상 관리 대상을 구분하고 관리 목록 번호 부여 |
| 버전 관리 | 진화 그래프 등을 통해 SCI의 버전 부여/갱신 |
| **변경 통제** | SCI에 대한 접근 및 동기화 제어 |
| 형상 감사 | SCI 무결성을 평가하여 공식적으로 승인 |
| 상태 보고 | 개발자와 유지 보수자에게 변경 사항을 공지 |

## 35. 사용성 테스트 기법: 성능 평가

- 8단원 5페이지
- 사용자가 실제로 제품이나 서비스와 연관된 것을 사용해 보고 태스크(TASK) 별 학습성, 효율성, 기억용이성, 오류, 만족도 등에 대해 평가하여, 그 결과를 바탕으로 성능을 개선한다. 제품이나 서비스를 개발하는 단계에 맞춰 평가를 진행한다.
- 페이퍼 프로토타입(가장 빠른 방법) 평가, 선호도(A가 B보다 더 좋다) 평가, 휴리스틱 평가(전문가에 의해 이론과 경험을 근거로 하여)가 있음

## 39. ifconfig

- 1단원 15페이지
- 처음에 필자는 `ifconfig --all`이라고 적어버렸지만 그냥 산업기사 시험이니만큼 `ifconfig`만 적기로 다시 한 번 다짐하였다.

## 40. 가중치 계산

- 9단원 49페이지
- 4.4가 나왔는데, 일단 이걸 440%라고도 표기하는 모양인데, 또 표 2-13을 보면 그대로 4.4라고 되어 있다.
- 일단 4 이상은 H, 3~4는 M, 3 이하는 L로 표기하는 모양이다.